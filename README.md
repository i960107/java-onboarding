# 과제 수행

- 각 문제의 제한사항에 위배되는 테스트케이스는 주어지지 않는다고 가정한다.
- 각 문제에서 사용된 함수들은 모두 해당 문제 클래스에 구현한다.
- 가독성, 유지보수성, 확장성을 고려해 기능을 구현한다.
- 미션은 [여기서](./docs/README.md) 자세히 확인할 수 있어요

## 문제1

[문제 확인](./docs/PROBLEM1.md)

### 💡풀이과정

1. 각 유저가 선택한 페이지를 하나의 참가자 리스트로 묶는다.
2. 선택한 페이지가 유효한지 판단한다.
    - 다음의 경우에 유효하지 않은 페이지이다
      (1) 시작면이나 마지막면인경우: 왼쪽이나 오른쪽 페이지가 null
      (2) 왼쪽페이지가 홀수, 오른쪽 페이지가 짝수가 아닌 경우
      (3) 연속된 페이지가 아닌 경우
      (4) 책의 페이지 번호 범위를 넘어가는 경우
3. 참가자들의 의 페이지 게임 점수를 계산한다.
4. 참가자들의 페이지 게임을 비교해 가장 큰 점수를 받은 참가자의 참가번호(index + 1)를 반환한다. 만약 무승부라면, 0을 반환한다.

### 🤔 특별히 고민한 점

1. 풀이과정 1.에서 하나의 리스트로 묶은 이유는 추후에 게임 참가자가 2인에서 더 늘어날 경우에 코드에 미치는 영향을 최소화하기 위해서이다.
2. 코드 내에 매직 넘버를 피하기 위해 무승부를 의미하는 상수 TIE, 예외사항을 의미하는 상수 EXCEPTION을 사용한다.
3. 풀이과정 3.을 3개의 함수로 분리해서 구현함으로써 한 함수가 하나의 기능만을 하도록 하였다.
    - 참가자 리스트를 반복하면서 각 참가자의 페이지 점수를 구하는 함수
    - 참가자의 왼쪽 페이지 점수, 오른쪽 페이지 점수를 구한 후 큰 값을 구하는 함수
    - 각 페이지에서 얻을 수 있는 최대 점수를 구하는 함수

## 문제2

[문제 확인](./docs/PROBLEM2.md)

### 💡풀이과정

1. 암호문을 문자 리스트로 변환한다.
2. 다음의 과정을 반복하여 문자 리스트를 복호화한다.
   (1) 연속된 문자가 있는지 확인한다.
   (2) 연속된 문자가 있다면, 연속된 문자열을 모두 삭제한 새로운 리스트를 만든다.
   (3) 만약 연속된 문자가 없다면 반복을 종료한다.
3. 복호화된 문자 리스트를 문자열로 변환한다.

### 🤔 특별히 고민한 점

1. 암호문을 문자 리스트로 변환하고, 복호화된 결과를 다시 String으로 바꾸어주는 이유.

## 문제3

[문제 확인](./docs/PROBLEM3.md)

### 💡풀이과정

1. 만약 1부터 number까지 총 손뼉수를 계산한 값이 저장되어 있다면 그 값을 반환한다.
2. 만약 1부터 number까지 총 손뼉수를 계산한 값이 저장되어 있지않다면, number-1까지 총 손뼉수와 number번째에 쳐야햐는 손뼉수를 더한 값이 총 손뼉수가 된다. 이 값을 저장한 후 반환한다.

### 🤔 특별히 고민한 점

1. 특정한 입력값일때 출력값이 항상 같음. 한번 계산한 입력값일 경우 저장해두고 다음에 다시 계산하지 않고 바로 반환. 이전에 계산한 값부터 현재 순서까지만 계산하면 됨.
2. 박수를 쳐야하는 규칙이 달라질 경우를 대비해서 조건을 상수로 관리해 확장에 열려있도록 한다.

## 문제4

[문제 확인](./docs/PROBLEM4.md)

### 💡풀이과정

1. 문자열의 각 문자를 반복하면서 개구리 언어로 변환한 새로운 문자 배열을 만든다.
2. 만들어진 문자배열을 문자열로 합친다.

## 문제5

[문제 확인](./docs/PROBLEM5.md)

### 💡풀이과정

1. 화폐단위를 내림차순으로 정렬한 배열을 반복하면서 가지고 있는 돈에서 각 단위별로 바꿀 수 있는 최대 화폐의 수를 계산한다.
2. 바꾼 총 화폐금액을 가지고 있는 돈에서 빼준다.

## 문제6

[문제 확인](./docs/PROBLEM6.md)

### 💡풀이과정

1. 모든 유저들의 닉네임에 대해서 2글자 부분 문자열을 key로 그 부분문자열을 포함하는 아이디들을 value로 하는 쌍들의 집합을 구한다.
   (1)  유저의 email 중 "email.com"을 제외한 부분인 아이디를 구한다.
   (2)  닉네임을 처음부터 두글자씩 자른 부분 문자열 집합을 구한다. 그 집합을 반복하면서, 각 부분 문자열을 포함하는 아이디들에 유저의 아이디를 추가한다.
   (3) 모든 유저들에 대해서 위 (1), (2)의 과정을 반복한다.
2. 1.에서 구한 집합을 활용해 중복된 닉네임들을 구한다. 각 부분문자열을 포함하는 아이디가 2개 이상일 경우 중복으로 간주한다.
3. 중복된 아이디들에 대해서 "email.com"붙여 원래 email을 구하고, 이메일을 기준으로 오름차순 정렬한다.

### 🤔 특별히 고민한 점

1. email 자체가 아니라 도메인을 제외한 아이디로 관리한다.
2. 아이디 집합은 Set으로 관리해 중복을 제거한다.
3. 도메인은 "email.com"으로 고정되어 있어 상수로 관리한다.

## 문제7

[문제 확인](./docs/PROBLEM7.md)

### 💡풀이과정

1. 친구 관계인 두 사람을 서로의 친구로 등록한 유저 - 친구들 쌍의 집합을 구한다.
2. 유저 - 친구들 쌍의 집합, 방문한 사람 리스트를 활용해 각 유저들의 추천 점수를 구한다.
3. 유저 자신이거나, 이미 유저의 친구로 등록되어있거나, 추천 점수가 0점인 경우 추천 대상이 아니므로 제외한다.
4. 추천 점수들을 조건에 맞춰 정렬한 후 최대 상위 5개의 유저를 추천한다.

### 🤔 특별히 고민한 점

1. 정렬 조건, 최대 추천 가능 유저 수, 최소 추천 점수, 함께 아는 친구 점수, 방문자 점수는 상수로 관리한다. 추천 로직이 변경되어도 상수만 변경하면 되므로 코드 변경을 최소화할 수 있다.
2. 추천 대상이 유저들의 리스트를 구해놓고, 매 점수 update시마다 유저가 추천대상인지 확인한 후 update하려고 했는데 -> 로직상 추천 직전에 추천대상인지 검증하는게 더 나음.

### 배운점

1. git을 사용하며 효율적으로 버전관리를 하기 위해서는 기능단위로 커밋을 작게 자주 하고, 명확한 커밋메세지를 작성하여 매 변경사항이 무엇인지 알 수 있어야 한다. 다만, 기능 단위를 구현한 함수 단위로
   생각했는데 그건 아닌 것 같음. 미리 알 수 없음. 논리적으로 한번에 일어나야 하는 함수들의 집합을 기능으로 생각하고 그 단위로 커밋을 한 후 각 커밋에 관련된 함수 리스트를 커밋 메세지에 작성하는게 어떨까?
   그러기 위해서는 미리 요구사항을 파악하여 문제 풀이 과정을 예측할 수 있어야 한다.